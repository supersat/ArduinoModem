/*
 * Bell103.c
 *
 *    Copyright 2014 Karl Koscher
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 * From Wikipedia (http://en.wikipedia.org/wiki/Bell_103_modem):
 *  The originating station used a mark tone of 1,270 Hz and a space tone of 1,070 Hz.
 *  The answering station used a mark tone of 2,225 Hz and a space tone of 2,025 Hz.
 *
 */ 


#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/pgmspace.h>
#include <avr/sleep.h>
#include <math.h>
#include <stdint.h>

const uint8_t sinTable[] PROGMEM = {
	0x80, 0x83, 0x86, 0x89, 0x8c, 0x8f, 0x92, 0x95, 0x98, 0x9b, 0x9e, 0xa1, 0xa4, 0xa7, 0xaa, 0xad,
	0xb0, 0xb3, 0xb6, 0xb9, 0xbb, 0xbe, 0xc1, 0xc3, 0xc6, 0xc9, 0xcb, 0xce, 0xd0, 0xd2, 0xd5, 0xd7,
	0xd9, 0xdb, 0xde, 0xe0, 0xe2, 0xe4, 0xe6, 0xe7, 0xe9, 0xeb, 0xec, 0xee, 0xf0, 0xf1, 0xf2, 0xf4,
	0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfb, 0xfc, 0xfd, 0xfd, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe,
	0xff, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfd, 0xfd, 0xfc, 0xfb, 0xfb, 0xfa, 0xf9, 0xf8, 0xf7, 0xf6,
	0xf5, 0xf4, 0xf2, 0xf1, 0xf0, 0xee, 0xec, 0xeb, 0xe9, 0xe7, 0xe6, 0xe4, 0xe2, 0xe0, 0xde, 0xdb,
	0xd9, 0xd7, 0xd5, 0xd2, 0xd0, 0xce, 0xcb, 0xc9, 0xc6, 0xc3, 0xc1, 0xbe, 0xbb, 0xb9, 0xb6, 0xb3,
	0xb0, 0xad, 0xaa, 0xa7, 0xa4, 0xa1, 0x9e, 0x9b, 0x98, 0x95, 0x92, 0x8f, 0x8c, 0x89, 0x86, 0x83,
	0x80, 0x7c, 0x79, 0x76, 0x73, 0x70, 0x6d, 0x6a, 0x67, 0x64, 0x61, 0x5e, 0x5b, 0x58, 0x55, 0x52,
	0x4f, 0x4c, 0x49, 0x46, 0x44, 0x41, 0x3e, 0x3c, 0x39, 0x36, 0x34, 0x31, 0x2f, 0x2d, 0x2a, 0x28,
	0x26, 0x24, 0x21, 0x1f, 0x1d, 0x1b, 0x19, 0x18, 0x16, 0x14, 0x13, 0x11, 0x0f, 0x0e, 0x0d, 0x0b,
	0x0a, 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x04, 0x03, 0x02, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
	0x0a, 0x0b, 0x0d, 0x0e, 0x0f, 0x11, 0x13, 0x14, 0x16, 0x18, 0x19, 0x1b, 0x1d, 0x1f, 0x21, 0x24,
	0x26, 0x28, 0x2a, 0x2d, 0x2f, 0x31, 0x34, 0x36, 0x39, 0x3c, 0x3e, 0x41, 0x44, 0x46, 0x49, 0x4c,
	0x4f, 0x52, 0x55, 0x58, 0x5b, 0x5e, 0x61, 0x64, 0x67, 0x6a, 0x6d, 0x70, 0x73, 0x76, 0x79, 0x7c,
};

const int8_t markSinTable[] PROGMEM = {
	0x00, 0x7e, 0xea, 0x85, 0x2c, 0x73, 0xbf, 0x99, 0x53, 0x58, 0x9d, 0xb9, 0x6f, 0x33, 0x88, 0xe2,
};

const int8_t markCosTable[] PROGMEM = {
	0x7f, 0xf5, 0x83, 0x21, 0x77, 0xc9, 0x93, 0x4a, 0x60, 0xa5, 0xb0, 0x69, 0x3d, 0x8c, 0xd7, 0x7b,
};

const int8_t spaceSinTable[] PROGMEM = {
	0x00, 0x7d, 0x2b, 0x92, 0xaf, 0x53, 0x6d, 0xd3, 0x83, 0x02, 0x7e, 0x29, 0x90, 0xb1, 0x54, 0x6c,
};

const int8_t spaceCosTable[] PROGMEM = {
	0x7f, 0x16, 0x88, 0xc1, 0x62, 0x60, 0xbf, 0x89, 0x18, 0x7f, 0x13, 0x88, 0xc3, 0x64, 0x5f, 0xbd,
};

typedef struct {
	// Buffer of the last 16 ADC samples
	int8_t sampleBuffer[16];
	uint8_t sampleBufOffset;
	//uint16_t lastBits;
	
	// Offset into the outgoing sine wave
	uint16_t phaseOut;
} line_t;

line_t line;

uint8_t countOnes(uint16_t n)
{
	uint8_t i;
	uint8_t count = 0;
	
	for (i = 0; i < 16; i++) {
		if (n & (1 << i))
			count++;
	}
	
	return count;
}
	
ISR(TIMER2_COMPA_vect) {
	uint8_t i;
	int8_t sample;
	int32_t miSum, mqSum, siSum, sqSum;
	int32_t sqrMISum, sqrMQSum, sqrSISum, sqrSQSum;
	//double sqrMISum, sqrMQSum, sqrSISum, sqrSQSum;
	
	PORTD |= _BV(PORTD2);
	
	// Read the RXD pin
	if (PIND & 1) {
		line.phaseOut += 30330; // ~2225 Hz
		//line.phaseOut += 17312; // ~1270 Hz
	} else {
		line.phaseOut += 27604; // ~2025 Hz
		//line.phaseOut += 14586; // ~1070 Hz
	}
	PORTB = pgm_read_byte(&sinTable[line.phaseOut >> 8]) >> 2;
	
	line.sampleBuffer[line.sampleBufOffset++] = (int8_t)(ADCH - 0x80);
	if (line.sampleBufOffset >= 16)
		line.sampleBufOffset = 0;
		
	miSum = 0;
	mqSum = 0;
	siSum = 0;
	sqSum = 0;
	
	for (i = 0; i < 16; i++) {
		sample = line.sampleBuffer[(i + line.sampleBufOffset) & 0xf];
		miSum = miSum + (int16_t)sample * (int8_t)pgm_read_byte(&markSinTable[i]);
		mqSum = mqSum + (int16_t)sample * (int8_t)pgm_read_byte(&markCosTable[i]);
		siSum = siSum + (int16_t)sample * (int8_t)pgm_read_byte(&spaceSinTable[i]);
		sqSum = sqSum + (int16_t)sample * (int8_t)pgm_read_byte(&spaceCosTable[i]);
	}

	if (miSum < 0)
		miSum = -miSum;
	if (mqSum < 0)
		mqSum = -mqSum;
	if (siSum < 0)
		siSum = -siSum;
	if (sqSum < 0)
		sqSum = -sqSum;

	miSum >>= 4;
	mqSum >>= 4;
	siSum >>= 4;
	sqSum >>= 4;

	sqrMISum = miSum * miSum;
	sqrMQSum = mqSum * mqSum;
	sqrSISum = siSum * siSum;
	sqrSQSum = sqSum * sqSum;
	
	//line.lastBits = line.lastBits << 1;
	if ((sqrMISum + sqrMQSum) > (sqrSISum + sqrSQSum)) {
		//line.lastBits |= 1;
		PORTD |= _BV(PORTD1);
	} else {
		PORTD &= ~_BV(PORTD1);
	}
	
	PORTD &= ~_BV(PORTD2);
	
	// Kick off the next ADC conversion
	ADCSRA |= _BV(ADSC);
	
}

int main(void)
{	
	PORTB = 0;
	DDRB = 63; // 6 bit DAC output
	PORTC = 0;
	DDRC = 0;
	DDRD = _BV(PORTD1) | _BV(PORTD2);
	
	// Initialize sample clock (~4800 Hz), assuming 16 MHz clock
	OCR2A = 51;
	TIMSK2 = _BV(OCIE2A);
    TCCR2A = _BV(WGM21); 
	TCCR2B = _BV(CS22);

	// Initialize the ADC
	ADCSRA = _BV(ADEN) | _BV(ADPS2) | _BV(ADPS1) | _BV(ADPS0);
	ADMUX = _BV(REFS0) | _BV(ADLAR);
	ADCSRB = 0;
	ADCSRA |= _BV(ADSC);

	// Kill the USART
	UCSR0B = 0;
		
	sei();
	
	for (;;) {
		sleep_mode();
	}
}
